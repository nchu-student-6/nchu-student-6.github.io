---
layout:     post
title:      JMM(java内存模型)
subtitle:   JMM是Java 定义的并发编程相关的一组规范，除了抽象了线程和主内存之间的关系之外，其还规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守规范（happens-before）。
date:       2024-08-10
author:     Zheng Yang
header-img: img/post-bg-article.jpg
catalog: true
tags:
    - java基础
---
# JMM

JMM(Java 内存模型)主要定义了对于一个共享变量，当另一个线程对这个共享变量执行写操作后，这个线程对这个共享变量的可见性。

## 从指令重排谈起

 简单来说就是系统在执行代码的时候并不一定是按照你写的代码的顺序依次执行。

另外，内存系统也会有“重排序”，但又不是真正意义上的重排序。在 JMM 里表现为主存和本地内存的内容可能不一致，进而导致程序在多线程下执行可能出现问题。

Java 源代码会经历 **编译器优化重排 —> 指令并行重排 —> 内存系统重排** 的过程，最终才变成操作系统可执行的指令序列。

**指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致** ，所以在多线程下，指令重排序可能会导致一些问题。

对于处理器，通过插入内存屏障（Memory Barrier) 的方式来禁止特定类型的处理器指令重排序。

> 内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种 CPU 指令，用来禁止处理器指令发生重排序（像屏障一样），从而保障指令执行的有序性。另外，为了达到屏障的效果，它也会使处理器写入、读取值之前，将主内存的值写入高速缓存，清空无效队列，从而保障变量的可见性。

## 什么是JMM

对于 Java 来说，你可以把 JMM 看作是 Java 定义的并发编程相关的一组规范，除了抽象了线程和主内存之间的关系之外，其还规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守规范。

**Java 内存模型（JMM）** 抽象了线程和主内存之间的关系，就比如说线程之间的共享变量必须存储在主内存中。

## **什么是主内存？什么是本地内存？**

- **主内存**：所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量，还是局部变量，类信息、常量、静态变量都是放在主内存中。
- **本地内存**：每个线程都有一个私有的本地内存，本地内存存储了该线程以读 / 写共享变量的副本。每个线程只能操作自己本地内存中的变量，无法直接访问其他线程的本地内存。如果线程间需要通信，必须通过主内存来进行。本地内存是 JMM 抽象出来的一个概念，并不真实存在。

Java 内存模型的抽象示意图如下：

[![image-20240810093749663.png](https://i.postimg.cc/DZhTjHS4/image-20240810093749663.png)](https://postimg.cc/cKF26DMd)
## happens-before原则

JMM可以通过[happens-before](https://so.csdn.net/so/search?q=happens-before&spm=1001.2101.3001.7020)关系向程序员提供跨线程的内存可见性保证。

在`JMM(JAVA内存模型)`中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在`happens-before`关系

**大白话：** **happens-before不要求前一个操作和后一个操作的发生顺序, 仅仅要求前一个操作的执行完成并刷新回内存（对后操作可见）发生在后一个操作结果之前**

