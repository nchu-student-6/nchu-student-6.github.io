---
layout:     post
title:      java虚拟机
subtitle:   从内存区域、类加载、垃圾回收说。
date:       2024-08-12
author:     Zheng Yang
header-img: img/post-bg-article.jpg
catalog: true
tags:
    - jvm
---
# jvm

## jvm内存区域

[![1713516291293-ce6ee4e7-c5a6-4395-9ee7-4ec1c014b206.webp](https://i.postimg.cc/G3YHHPxt/1713516291293-ce6ee4e7-c5a6-4395-9ee7-4ec1c014b206.webp)](https://postimg.cc/MX6WLQ4J)
- **元空间**：元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。
- **Java 虚拟机栈**：每个线程有一个私有的栈，随着线程的创建而创建。栈里面存着的是一种叫“栈帧”的东西，每个方法会创建一个栈帧，栈帧中存放了局部变量表（基本数据类型和对象引用）、操作数栈、方法出口等信息。栈的大小可以固定也可以动态扩展。
- **本地方法栈**：与虚拟机栈类似，区别是虚拟机栈执行java方法，本地方法站执行native方法。在虚拟机规范中对本地方法栈中方法使用的语言、使用方法与数据结构没有强制规定，因此虚拟机可以自由实现它。
- **程序计数器：**程序计数器可以看成是当前线程所执行的字节码的行号指示器。在任何一个确定的时刻，一个处理器（对于多内核来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，我们称这类内存区域为“线程私有”内存。
- **堆内存**：堆内存是 JVM 所有线程共享的部分，在虚拟机启动的时候就已经创建。所有的对象和数组都在堆上进行分配。这部分空间可通过 GC 进行回收。当申请不到空间时会抛出 OutOfMemoryError。堆是JVM内存占用最大,最复杂的区域。
- **直接内存**：直接内存并不是虚拟机运行时数据区的一部分，也不是Java 虚拟机规范中农定义的内存区域。在JDK1.4 中新加入了NIO(New Input/Output)类，引入了一种基于通道(Channel)与缓冲区（Buffer）的I/O 方式，它就是native 函数库直接分配在堆外的内存，然后通过一个irectByteBuffer 对象进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。
> NIO（non-blocking IO） ：Java 1.4 引入的 java.nio 包，提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层高性能的数据操作方式。

> BIO（blocking IO）：就是传统的 java.io 包，它是基于流模型实现的，交互的方式是同步、阻塞方式，也就是说在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。优点是代码比较简单、直观；缺点是 IO 的效率和扩展性很低，容易成为应用性能瓶颈。

> AIO（Asynchronous IO） ：是 Java 1.7 之后引入的包，是 NIO 的升级版本，提供了异步非堵塞的 IO 操作方式，所以人们叫它 AIO（Asynchronous IO），异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。
>
> 同步阻塞：
> 鲁智深排队（阻塞）打酒，时不时问小二，等着酒（同步）被盛好；
> 异步阻塞：
> 鲁智深排队（阻塞）打酒，等着叫号机器或者大屏通知（异步）响应；
> 同步不阻塞：
> 鲁智深酒馆打酒，坐着玩手机（不阻塞），时不时问小二，等着酒（同步）被盛好；
> 异步不阻塞：
> 鲁智深酒馆打酒，坐着玩手机（不阻塞），等着叫号机器或者大屏通知（异步）响应
>
> 同步与异步的区别在于：
> 同步：请求与响应同时进行，直到响应再返回结果；
> 异步：请求直接返回空结果，不会立即响应，但一定会有响应，通过通知（叫号机）、状态（大屏通知）、回调函数响应
>
> 阻塞与非阻塞的区别在于：
> 阻塞：请求后一直等待
> 非阻塞：请求后，可以继续干其他事，直到响应
## 类加载流程
[![1719491354969-a7c861d7-531e-45d3-a4aa-4696710ec297.webp](https://i.postimg.cc/MTBKfxRN/1719491354969-a7c861d7-531e-45d3-a4aa-4696710ec297.webp)](https://postimg.cc/gXYP1CgH)
- **加载：**通过类的全限定名（包名 + 类名），获取到该类的.class文件的二进制字节流加载进虚拟机，将二进制字节流所代表的数据结构，转化为方法区运行时的数据结构，在内存中生成一个代表该类的java.lang.Class对象，作为方法区这个类的访问入口。
- **连接：**验证、准备、解析 3 个阶段统称为连接。
  - **验证**：确保class文件中的字节流包含的信息，符合当前虚拟机的要求，保证这个被加载的class类的正确性，不会危害到虚拟机的安全。验证阶段大致会完成以下四个阶段的检验动作：文件格式校验、元数据验证、字节码验证、符号引用验证
  - **准备**：为类中的静态字段分配内存，并设置默认的初始值，比如int类型初始值是0。被final修饰的static字段不会设置，因为final在编译的时候就分配了。
  - **解析：**解析阶段是虚拟机将常量池的「符号引用」直接替换为「直接引用」的过程。如果有了直接引用， 那引用的目标必定已经存在在内存中了。

- **初始化：**初始化是整个类加载过程的最后一个阶段，初始化阶段简单来说就是执行类的构造器方法（() ），要注意的是这里的构造器方法()并不是开发者写的，而是编译器自动生成的。
- **使用：**使用类或者创建对象
- **卸载：**如果有下面的情况，类就会被卸载：1. 该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。2. 加载该类的ClassLoader已经被回收。 

## 双亲委派机制

[![1719491243997-d62ceba6-2073-41a6-8320-dbe47ce9dbe4.png](https://i.postimg.cc/65fqh9SN/1719491243997-d62ceba6-2073-41a6-8320-dbe47ce9dbe4.png)](https://postimg.cc/KR4mGyx9)

其核心思想是当一个类加载器收到类加载的请求时，首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中。

- **保证类的唯一性**：通过委托机制，确保了所有加载请求都会传递到启动类加载器，避免了不同类加载器重复加载相同类的情况，保证了Java核心类库的统一性。
- **保证安全性**：由于Java核心库被启动类加载器加载，而启动类加载器只加载它信任的类，这样可以防止不可信的类假冒核心类，增强了系统的安全性。例如，恶意代码无法自定义一个java.lang.System类并加载到JVM中，因为这个请求会被委托给启动类加载器，而启动类加载器只会加载标准的Java库中的类。
- **支持隔离和层次划分**：双亲委派模型支持不同层次的类加载器服务于不同的类加载需求，如应用程序类加载器加载用户代码，扩展类加载器加载扩展框架，启动类加载器加载核心库，便于维护和扩展。
- **简化了加载流程**：通过委派，大部分类能够被正确的类加载器加载，减少了每个加载器需要处理的类的数量，简化了类的加载过程，提高了加载效率。

## 对象的生命周期

对象的生命周期包括创建、使用和销毁三个阶段：

- 创建：对象通过关键字new在堆内存中被实例化，构造函数被调用，对象的内存空间被分配。
- 使用：对象被引用并执行相应的操作，可以通过引用访问对象的属性和方法，在程序运行过程中被不断使用。
- 销毁：当对象不再被引用时，通过垃圾回收机制自动回收对象所占用的内存空间。垃圾回收器会在适当的时候检测并回收不再被引用的对象，释放对象占用的内存空间，完成对象的销毁过程。

## 垃圾回收

### 断垃圾的方法有哪些？

**引用计数法和可达性分析算法**

> 引用计数法（Reference Counting）

- **原理**：为每个对象分配一个引用计数器，每当有一个地方引用它时，计数器加1；当引用失效时，计数器减1。当计数器为0时，表示对象不再被任何变量引用，可以被回收。
- **缺点**：不能解决循环引用的问题，即两个对象相互引用，但不再被其他任何对象引用，这时引用计数器不会为0，导致对象无法被回收。

> 可达性分析算法（Reachability Analysis）

- **原理**：从一组称为GC Roots（垃圾收集根）的对象出发，向下追溯它们引用的对象，以及这些对象引用的其他对象，以此类推。如果一个对象到GC Roots没有任何引用链相连（即从GC Roots到这个对象不可达），那么这个对象就被认为是不可达的，可以被回收

[![1719111821599-650b1691-2737-453b-ba4b-26b065a96e88.png](https://i.postimg.cc/SxQsTBFY/1719111821599-650b1691-2737-453b-ba4b-26b065a96e88.png)](https://postimg.cc/Xph4XDvn)
### 垃圾回收算法有哪些？

- **标记-清除算法**：标记-清除算法分为“标记”和“清除”两个阶段，首先通过可达性分析，标记出所有需要回收的对象，然后统一回收所有被标记的对象。标记-清除算法有两个缺陷，一个是效率问题，标记和清除的过程效率都不高，另外一个就是，清除结束后会造成大量的碎片空间。有可能会造成在申请大块内存的时候因为没有足够的连续空间导致再次 GC。
- **复制算法**：为了解决碎片空间的问题，出现了“复制算法”。复制算法的原理是，将内存分成两块，每次申请内存时都使用其中的一块，当内存不够时，将这一块内存中所有存活的复制到另一块上。然后将然后再把已使用的内存整个清理掉。复制算法解决了空间碎片的问题。但是也带来了新的问题。因为每次在申请内存时，都只能使用一半的内存空间。内存利用率严重不足。
- **标记-整理算法**：标记-整理算法的“标记”过程与“标记-清除算法”的标记过程一致，但标记之后不会直接清理。而是将所有存活对象都移动到内存的一端。移动结束后直接清理掉剩余部分。
- **分代回收算法**：分代收集是将内存划分成了新生代和老年代。分配的依据是对象的生存周期，或者说经历过的 GC 次数。对象创建时，一般在新生代申请内存，当经历一次 GC 之后如果对还存活，那么对象的年龄 +1。当年龄超过一定值(默认是 15，可以通过参数 -XX:MaxTenuringThreshold 来设定)后，该对象会进入老年代。

### 垃圾回收器有哪些？

[![1712649527581-d6aee0bf-35ab-4406-8a26-270b35ae8771.png](https://i.postimg.cc/xdJ9BYs8/1712649527581-d6aee0bf-35ab-4406-8a26-270b35ae8771.png)](https://postimg.cc/06vgwg11)
- Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效；
- ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；
- Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；
- Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年代版本；
- Parallel Old收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；
- CMS(Concurrent Mark Sweep)收集器（标记-清除算法）： 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。
- G1(Garbage First)收集器 (标记-整理算法)： Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代

### minorGC、majorGC、fullGC的区别，什么场景触发full GC?

在Java中，垃圾回收机制是自动管理内存的重要组成部分。根据其作用范围和触发条件的不同，可以将GC分为三种类型：Minor GC（也称为Young GC）、Major GC（有时也称为Old GC）、以及Full GC。以下是这三种GC的区别和触发场景：

> Minor GC (Young GC)

- **作用范围**：只针对年轻代进行回收，包括Eden区和两个Survivor区（S0和S1）。
- **触发条件**：当Eden区空间不足时，JVM会触发一次Minor GC，将Eden区和一个Survivor区中的存活对象移动到另一个Survivor区或老年代（Old Generation）。
- **特点**：通常发生得非常频繁，因为年轻代中对象的生命周期较短，回收效率高，暂停时间相对较短。

> Major GC

- **作用范围**：主要针对老年代进行回收，但不一定只回收老年代。
- **触发条件**：当老年代空间不足时，或者系统检测到年轻代对象晋升到老年代的速度过快，可能会触发Major GC。
- **特点**：相比Minor GC，Major GC发生的频率较低，但每次回收可能需要更长的时间，因为老年代中的对象存活率较高。

> Full GC

- **作用范围**：对整个堆内存（包括年轻代、老年代以及永久代/元空间）进行回收。
- **触发条件**：
  - 直接调用`System.gc()`或`Runtime.getRuntime().gc()`方法时，虽然不能保证立即执行，但JVM会尝试执行Full GC。
  - Minor GC（新生代垃圾回收）时，如果存活的对象无法全部放入老年代，或者老年代空间不足以容纳存活的对象，则会触发Full GC，对整个堆内存进行回收。
  - 当永久代（Java 8之前的版本）或元空间（Java 8及以后的版本）空间不足时。
- **特点**：Full GC是最昂贵的操作，因为它需要停止所有的工作线程（Stop The World），遍历整个堆内存来查找和回收不再使用的对象，因此应尽量减少Full GC的触发

### 垃圾回收器 CMS 和 G1的区别？

**区别一：使用的范围不一样：**

- CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用
- G1收集器收集范围是老年代和新生代。不需要结合其他收集器使用

**区别二：STW的时间：**

- CMS收集器以最小的停顿时间为目标的收集器。
- G1收集器可预测[垃圾回收 (opens new window)](https://so.csdn.net/so/search?q=垃圾回收&spm=1001.2101.3001.7020)的停顿时间（建立可预测的停顿时间模型）

**区别三： 垃圾碎片**

- CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片
- G1收集器使用的是“标记-整理”算法，进行了空间整合，没有内存空间碎片。

**区别四： 垃圾回收的过程不一样**

[![1716015294690-efd71a12-f4b1-4356-9de2-5164393482a5.png](https://i.postimg.cc/vmcmM5mQ/1716015294690-efd71a12-f4b1-4356-9de2-5164393482a5.png)](https://postimg.cc/McJwmMR4)
注意这两个收集器第四阶段得不同

**区别五: CMS会产生浮动垃圾**

- CMS产生浮动垃圾过多时会退化为serial old，效率低，因为在上图的第四阶段，CMS清除垃圾时是并发清除的，这个时候，垃圾回收线程和用户线程同时工作会产生浮动垃圾，也就意味着CMS垃圾回收器必须预留一部分内存空间用于存放浮动垃圾
- 而G1没有浮动垃圾，G1的筛选回收是多个垃圾回收线程并行gc的，没有浮动垃圾的回收，在执行‘并发清理’步骤时，用户线程也会同时产生一部分可回收对象，但是这部分可回收对象只能在下次执行清理是才会被回收。如果在清理过程中预留给用户线程的内存不足就会出现‘Concurrent Mode Failure’,一旦出现此错误时便会切换到SerialOld收集方式。

### 
